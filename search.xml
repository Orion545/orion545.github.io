<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>test</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Solution of LOJ3089]]></title>
    <url>%2FLOJ3089%2F</url>
    <content type="text"><![CDATA[Problem Statementlink to loj.ac Main IdeasThe Answer looks like a product of different items under a sqrt, therefore a basic tecnique is to use ln. After this, calculation of product is changed to calculation of sum, which looks like: \sqrt[n]{\prod_i a_i}=\frac{1}{n}\sum_i\log_ba_iNow the problem is to seek the maximum average value of gem sequences that match the model string. When a problem of strings contains ONE model and MANY patterns, AC Automaton should come to one’s mind at once! We build the AC Automaton for the model string, and do dynamic programming on it, thus the problem should be solved. MIND that each node on the AC Automaton should inherit all the information of its ancestors on the fail-pointer tree. When a problem that asks for minimize/maximize the average for a certain set of values, Linear Programming should come to one’s mind at once! Assume that the average for the current set of model strings is $C$, it is obvious that we can do binary search to determine its value. Then if there is a set of {w} that results in an average larger than $C$, the following expression should be true: \frac{1}{siz}\sum_{i=1}^{siz}w_i\geq C\sum_{i=1}^{siz}w_i\geq C\ast siz\sum_{i=1}^{siz}(w_i-C)\geq 0Now we can use the sign of the largest possibel {w} to determine if the current C is the answer. The benefit of this algorithm is that we can delete one dimension of our DP on the AC Automaton, thus the Complexity is divided by n We assume dp[u][i] represents this state: iteration on the first i characters of the model string has been finished, and the pointer on AC Automaton is at node u If the next character of the model string is fixed, we simply update the value for dp[sonu(str[i+1])][i+1], else we’ll have to update all values of dp[sonu(0…9)][i+1] For more Details, refer to the code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118/*------------------------------Author: Orion545Date: 2019/05/16Time: 157 min------------------------------*/#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cassert&gt;#include&lt;queue&gt;#include&lt;cmath&gt;#define ll long longusing namespace std;inline int read()&#123; int re=0,flag=1;char ch=getchar(); while(!isdigit(ch))&#123; if(ch=='-') flag=-1; ch=getchar(); &#125; while(isdigit(ch)) re=(re&lt;&lt;1)+(re&lt;&lt;3)+ch-'0',ch=getchar(); return re*flag;&#125;int n,m;double w[1510];char a[1510],s[1510][1510];int ch[1510][10],cntn=0,num[1510],fail[1510];double sum[1510];//AC Automatoninline void insert(int x,int len)&#123; int i,cur=0,tmp; for(i=1;i&lt;=len;i++)&#123; tmp=s[x][i]-'0'; if(!ch[cur][tmp]) ch[cur][tmp]=++cntn; cur=ch[cur][tmp]; &#125; num[cur]++;sum[cur]+=w[x];&#125;queue&lt;int&gt;q;inline void build()&#123; int i,u,v; for(i=0;i&lt;10;i++)&#123; if(!ch[0][i]) continue; q.push(ch[0][i]);fail[ch[0][i]]=0; &#125; while(!q.empty())&#123; u=q.front();q.pop(); num[u]+=num[fail[u]]; sum[u]+=sum[fail[u]]; for(i=0;i&lt;10;i++)&#123; v=ch[u][i]; if(v) fail[v]=ch[fail[u]][i],q.push(v); else ch[u][i]=ch[fail[u]][i]; &#125; &#125;&#125;//Dynamic Programmingdouble dp[1510][1510];int from[1510][1510][2],endpos;inline bool check(double mid)&#123; int i,j,k,son; for(i=0;i&lt;=n;i++) for(j=0;j&lt;=cntn;j++) dp[i][j]=-2e20; for(i=0;i&lt;=cntn;i++)&#123; sum[i]-=mid*(double)num[i];//cut the value according to binary search process &#125; dp[0][0]=0; for(i=1;i&lt;=n;i++)&#123; for(j=0;j&lt;=cntn;j++)&#123; if(dp[i-1][j]==-2e20) continue; if(a[i]!='.')&#123;//character is fixed in original S son=ch[j][a[i]-'0']; if(dp[i][son]&lt;dp[i-1][j]+sum[son])&#123; dp[i][son]=dp[i-1][j]+sum[son]; from[i][son][0]=j;//record the source of the maximum value from[i][son][1]=a[i]-'0';//record the corresponding character &#125; &#125; else&#123;//character is unfixed for(k=0;k&lt;10;k++)&#123; son=ch[j][k]; if(dp[i][son]&lt;dp[i-1][j]+sum[son])&#123; dp[i][son]=dp[i-1][j]+sum[son]; from[i][son][0]=j; from[i][son][1]=k; &#125; &#125; &#125; &#125; &#125; int pos=0; for(i=1;i&lt;=cntn;i++) if(dp[n][i]&gt;dp[n][pos]) pos=i; for(i=0;i&lt;=cntn;i++) sum[i]+=mid*(double)num[i];//repair the value cut endpos=pos;return dp[n][pos]&gt;0;//determine if largest value is over zero&#125;char re[1510];int main()&#123; n=read();m=read();int i; scanf("%s",a+1); for(i=1;i&lt;=m;i++)&#123; scanf("%s",s[i]+1); w[i]=read(); w[i]=log((double)w[i]); insert(i,strlen(s[i]+1)); &#125; build(); double l=0,r=log(1e9+7),mid,ans=0; while(r-l&gt;1e-6)&#123;//binary search mid=(l+r)*0.5; if(check(mid)) ans=mid,l=mid; else r=mid; &#125; check(ans); for(i=n;i&gt;=1;i--)&#123;//get the answer string re[i]=from[i][endpos][1]+'0'; endpos=from[i][endpos][0]; &#125; for(i=1;i&lt;=n;i++) putchar(re[i]); putchar('\n');&#125;]]></content>
      <categories>
        <category>OI Solution</category>
      </categories>
      <tags>
        <tag>AC Automaton</tag>
        <tag>DP</tag>
      </tags>
  </entry>
</search>
